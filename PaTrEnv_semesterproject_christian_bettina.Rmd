---
title: "Semseterprojekt Wildschweinschreck"
output: html_document
---

ADD CHUNK by clicking ctrl+alt+I

```{r libraries, echo=F, results='hide', message=F, warning=F}

library(readr)        # to import tabular data (e.g. csv)
library(dplyr)        # to manipulate (tabular) data
library(ggplot2)      # to visualize data
library(sf)           # to handle spatial vector data
library(terra)        # To handle raster data
library(lubridate)    # To handle dates and times
library(zoo)
#install.packages("devtools")
library(devtools)
library(ComputationalMovementAnalysisData)
library(forcats)
library(plotly)
```



```{r Daten einlesen, echo=F, results='hide', message=F, warning=F}
devtools::install_github("ComputationalMovementAnalysis/ComputationalMovementAnalysisData")
head(wildschwein_BE)
wildschwein_BE<-wildschwein_BE
wildschwein_metadata<-wildschwein_metadata
wildschwein_overlap_temp<-wildschwein_overlap_temp
schreck_agenda<-schreck_agenda
schreck_locations<-schreck_locations
```


## Das Sampling Regime der Wildschweine
```{r Nils Plot on sampling regime, echo=T, results='hide', message=F, warning=F}
limits <- c(0,200)
breaks = seq(0,200,50)
labels = paste(c(rep("",length(breaks)-1),">"), breaks)

wildschwein_BE %>%
  mutate(TierName = fct_reorder(TierName, DatetimeUTC,min, .desc = TRUE)) %>%
  group_by(TierID, TierName, CollarID) %>%
  mutate(
    timelag = as.numeric(difftime(lead(DatetimeUTC),DatetimeUTC, units = "mins")),
    ) %>%
  ggplot(aes(DatetimeUTC, TierName, colour = timelag)) +
  geom_line(lwd = 10) +
  scale_color_gradientn(name = "Sampling interval", colours = RColorBrewer::brewer.pal(11, "Spectral"), limits = limits, na.value = NA, oob = scales::squish, breaks = seq(0,200,50), labels = labels) +
  theme_minimal() +
  theme(legend.position = "top") +
  guides(color = guide_colorbar(title.position = "top", title.hjust = .5, barwidth = unit(20, "lines"), barheight = unit(.5, "lines")))

```


## Die geografischen Zusammenhänge zwischen den Wildschweinen un den Wildschwein-Schrecks
```{r Überblick über den geografischen Overlap zwischen den Wildschweinen und den Wildschwein-Schrecks, echo=T, results='hide', message=F, warning=F}
# Ortsbezogne Wildschweindaten werden  CRS 2056 zugewiesen
wildschwein_sf <- wildschwein_BE %>%
  st_as_sf(coords = c("E", "N"), crs = 2056) %>%
  mutate(tiercollar = paste(TierID, TierName, CollarID))
wildschwein_sf

# Die ortsbezogenen Wilschweinschreck-Daten werden dem CRS 4326 zugewiesen und zu 2056 umgewandelt
WSS_sf <- schreck_locations%>%
  st_as_sf(coords = c("N","E"), crs=4326, remove = FALSE) #N and E waren vertauscht

WSS_sf <- st_transform(WSS_sf, 2056)
WSS_sf
str(WSS_sf)

# wir möchten die Koordinaten in Einzelspalten. Mit folgendem Code erhalten wir x (für N) und y (für E)
WSS_sf <- WSS_sf %>%
  cbind(., st_coordinates(WSS_sf))


# Ein Convex-Hull wird erstellt und geplottet, um die Verteilung der Wildschweine aufzuzeigen
wildschwein_convex_hull <- wildschwein_sf %>%
  group_by(TierID, TierName, CollarID) %>%
  summarise() %>%
  st_convex_hull()

wildschwein_convex_hull %>%
  mutate(tiercollar = paste(TierID, TierName, CollarID))%>%
  ggplot(aes(fill = factor(TierID))) + geom_sf(alpha = 0.1) +
  coord_sf(datum = 2056) +
  facet_wrap(~tiercollar) +
  theme(legend.position = "none")

wildschwein_convex_hull %>%
  mutate(tiercollar = paste(TierID, TierName, CollarID))

# Zusätzlich wird der Zusammenhang der Wildschweine und der Wildschweinschrecks aufgezeigt
plot_boars_schreck<-ggplot()+
 geom_sf(data = wildschwein_convex_hull, aes(fill = factor(TierID), alpha=0.1))+
 geom_sf(data = WSS_sf, aes(color=factor(id)))+
  coord_sf(datum = 2056)+
  theme(legend.position = "none")

ggplotly(plot_boars_schreck)

# jetzt können alle Wildschweinschrecks rausgefiltert werden, die nicht in den convex hulls sind. Viele der Wildschweinschrecks sind ausserhalb des Aufenthaltsgebiets von Wildschweinen. Wir machen das explorativ, d.h. wir grenzen die Koordinaten gemäss dem Plot ein.
WSS_sf_relevant <- WSS_sf%>%
  filter(X <= 2580000 & X>2560000 & Y <= 1210000   & Y > 119000) # Alle Wildschwienschrecks im näheren Umkreis der Wildschwein-Aufethaltsgebiete sind in WSS_sf_relevant gespiechert
	
# hier nochmal der Plot, nur noch mit den relevanten Wildschweinschrecks
plot_boars_schreck_rel<-ggplot()+
 geom_sf(data = wildschwein_convex_hull, aes(fill = factor(TierID), alpha=0.1))+
 geom_sf(data = WSS_sf_relevant, aes(color=factor(id)))+
  coord_sf(datum = 2056)+
  theme(legend.position = "none")
  #xlim(2560000,2580000)+
  #ylim(1190000,1210000)
plot_boars_schreck_rel
```

## Die zeitlich und geografisch relevanten Wildschweinschrecks in Abhängigkeit der Wildschweindaten
```{r  Zeitbezogene Daten des Wildscheinschrecks, echo=T, results='hide', message=F, warning=F}

# alle Daten die sich nicht mit den Wilschweinen überschneiden löschen
summary(wildschwein_BE$DatetimeUTC)
schreck_agenda_relevant <- schreck_agenda%>%
  filter(datum_on > "2014-05-28" & datum_on < "2016-10-18") # somit sind alle Schrecks rausgefiltert, die vor der Messung der Wildschweine schon einen Alarmton von sich geben und alle Schrecks die nach der Periode der Wildschweinmessung noch einen Ton von sich geben. Denn basierend darauf können wir keine Analysen machen. 

# alle Wildschweinschrecks die ausserhalb des Wildschweingebiets sind und die nicht der richtigen Zeitperiode entsprechen, wurden gelöscht.Es entsteht der finale Datensatz für die Wildschweinschrecks, mit dem wir arbeiten wollen (schreck_agenda_relevant)
# MIT DIESEM DATENSATZ ARBEITEN WIR FÜR DIE WILDSCHWEINSCHRECKANALYSE
schreck_agenda_relevant <- left_join(WSS_sf_relevant,schreck_agenda_relevant,by="id")
schreck_agenda_relevant <- schreck_agenda_relevant %>%
  na.omit(datum_on)

schreck_agenda_relevant$modus<-as.factor(schreck_agenda_relevant$modus)

ggplot(schreck_agenda_relevant, aes(xmin = datum_on, xmax = datum_off, y=factor(id)))+
         geom_errorbarh(aes(color = modus))
```


## Die Herausfilterung der Wildschweindaten, deren gemessenen Zeitperioden sich über die der relevanten Wildschweinschrecks ausweitet
```{r welche wildschweine werden zeitgleich mit dem Wildschweinschreck-Alarm gemessen, echo=T, results='hide', message=F, warning=F}

# Nachfolgend werden die Samplingperioden mit den Werten mix und max pro Tier und Halsband identifiziert
sampling_periods <- wildschwein_BE %>%
  group_by(TierID, TierName, CollarID) %>%
  summarise(
    min = min(DatetimeUTC),
    max = max(DatetimeUTC)
  )

# es muss ein Intervall gebildet werden, damit nachfolgend herausgefunden werden kann, ob die Wildschweinschrecks innerhalb einer Wildschwein-Messperiode eingestellt waren (d.h. Ein- UND Ausschaltung während der Messperiode der Schweine stattfindet (idealfall). Würde dieser Idealfall nicht eintreten, könne man evtl. auch andere mögliche Schweine bestimmen.  
intervall_wildschwein <- sampling_periods$min %--% sampling_periods$max #1) Intervallbildung

sampling_periods$WSS_on_within_WS_intervalls<-schreck_agenda_relevant$datum_on %within% intervall_wildschwein #ist die Einschaltung innterhalb der Messperiode der Wildschweine?
sampling_periods$WSS_off_within_WS_intervalls<-schreck_agenda_relevant$datum_off %within% intervall_wildschwein # ist die Ausschaltung innterhalb der Messperiode der Wildschweine?

# Jetzt werden alle Schweine herausgefiltert, die vor der Einschaltung, während der Messperiode und nach der Ausschaltung der noch in Frage kommenden Wildschweinschrecks gemessen werden. d.h. alle die die Ein- und Ausschaltung überdauern. 
sampling_periods_relevant <- sampling_periods %>%
  filter(WSS_on_within_WS_intervalls==TRUE & WSS_off_within_WS_intervalls==TRUE) %>%
  mutate(tiercollar = paste(TierID, TierName, CollarID))

# es verbleiben 5 relevante Wildschweine in sampling_periods_relevant. Diese Wildschweine werden nun im Detaildatensatz der Wildschweine, mit allen relevanten Daten, herausgefiltert.

#MIT DIESEM DATENSATZ ARBEITEN WIR FÜR DIE WILDSCHWEINANALYSE
wildschwein_sf_relevant <- wildschwein_sf %>%
  filter(tiercollar == "2 Sabine 12275" | tiercollar == "36 Olga 13976" | tiercollar == "40 Franz 12273" | tiercollar == "60 Venus 13969" | tiercollar == "84 Gaby 12274" )

# Es muss wiederum ein Convexhull erstellt werden, für den gefilterten Wildschwiendatensatz
sampling_periods_relevant_convexhull <- wildschwein_sf_relevant %>%
  group_by(TierID, TierName, CollarID, tiercollar) %>%
  summarise() %>%
  st_convex_hull()


# Zuletzt wird nochmal der gleiche Plot wie anfangs erstellt, einfach nur noch mit den Relevanten Wildschweinschrecks und den relevanten Wildschweinen.
plot_boars_schreck_rel_spattemp<-ggplot()+
 geom_sf(data = sampling_periods_relevant_convexhull, aes(fill = factor(tiercollar), alpha=0.1))+
 geom_sf(data = schreck_agenda_relevant, aes(color=factor(id)))+
  coord_sf(datum = 2056)


plot_boars_schreck_rel_spattemp
```



## R Markdown tipps and tricks

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
